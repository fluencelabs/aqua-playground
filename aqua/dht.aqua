import "@fluencelabs/aqua-dht/dht.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

service OpHack("op"):
  identity(r: []Record) -> []Record


service OpHack2("op"):
  identity(r: [][]Record) -> [][][]Record  

func setKey(node_id: string, key: string, value: string, relay_id: string, ack: string, string -> ()) -> []string:
  on node_id:
    k <- Op.string_to_b58(key)
    nodes <- Kademlia.neighborhood(k, false)
    tt <- Peer.timestamp_sec()
    AquaDHT.register_key(key, tt)
    ack("node end", node_id)
  for n <- nodes par:
    on n:
      try:
        ack("begin", n)
        t <- Peer.timestamp_sec()
        AquaDHT.register_key(key, t)
        AquaDHT.put_value_relay(key, value, t, relay_id)
        ack("end", n)
  <- nodes

func getValues(node_id: string, key: string, ack: string, []GetValuesResult -> ()) -> []Record:
  on node_id:
    k <- Op.string_to_b58(key)
    nodes <- Kademlia.neighborhood(k, false)
  res: *GetValuesResult  
  for n <- nodes:
    on n:
      try:
        t <- Peer.timestamp_sec()
        res <- AquaDHT.get_values(key, t)
  -- join when 2 results are there
  on node_id:
    ack("values", res)
    v <- AquaDHT.merge_hack_get_values(res)      
  <- v.result
