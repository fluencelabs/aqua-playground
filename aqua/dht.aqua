import "@fluencelabs/aqua-dht/dht.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

-- putValue
-- putHostValue
-- setKeyPutHostValue
-- clearHostValue


-- separate file for node
-- replicate
-- neighborhood -> timestamp -> getRecords (evictStale) -> republish_key -> republish_values
-- clearExpired
-- timestamp -> call clearExpired

func getNeighbours(key: string, node_id: string) -> []PeerId:
  on node_id:
    k <- Op.string_to_b58(key)
    nodes <- Kademlia.neighborhood(k, false)
  <- nodes

func clearHostValue(key: string, node_id: string):
  nodes <- getNeighbours(key, node_id)
  for n <- nodes par:
    on n:
      try:
        t <- Peer.timestamp_sec()
        AquaDHT.clear_host_value(key, t)

func registerKey(node_id: string, key: string, weight: u32) -> []string:
  nodes <- getNeighbours(key, node_id)
  for n <- nodes par:
    on n:
      try:
        t <- Peer.timestamp_sec()
        AquaDHT.register_key(key, t, true, weight)
  <- nodes

func setKeyPutValue(node_id: string, key: string, value: string, relay_id: string, weight: u32) -> []string:
  nodes <- getNeighbours(key, node_id)
  for n <- nodes par:
    on n:
      try:
        t <- Peer.timestamp_sec()
        AquaDHT.register_key(key, t, true, weight)
        AquaDHT.put_value_relay(key, value, t, relay_id, weight)
  <- nodes

func putValue(node_id: string, key: string, value: string, relay_id: string, weight: u32) -> []string:
  nodes <- getNeighbours(key, node_id)
  for n <- nodes par:
    on n:
      try:
        t <- Peer.timestamp_sec()
        AquaDHT.put_value_relay(key, value, t, relay_id, weight)
  <- nodes

func putHostValue(node_id: string, key: string, value: string, relay_id: []string, service_id: []string, weight: u32) -> []string:
  nodes <- getNeighbours(key, node_id)
  for n <- nodes par:
    on n:
      try:
        t <- Peer.timestamp_sec()
        AquaDHT.put_host_value(key, value, t, relay_id, service_id, weight)
  <- nodes

-- not working
func getValues(node_id: string, key: string) -> []Record:
  on node_id:
    k <- Op.string_to_b58(key)
    nodes <- Kademlia.neighborhood(k, false)
    res: *GetValuesResult
    for n <- nodes:
      on n:
        try:
          t <- Peer.timestamp_sec()
          res <- AquaDHT.get_values(key, t)
    v <- AquaDHT.merge_hack_get_values(res)      
  <- v.result
